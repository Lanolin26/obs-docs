---
source: https://habr.com/ru/articles/850990/
tags: [victoriametrics,prometheus]
habs: [Серверное администрирование,Системное администрирование,Хранение данных]
---
# Как снизить расходы на мониторинг  замена Prometheus на VictoriaMetrics
Мониторинг может оказаться дорогим делом из\-за огромных объемов данных, которые необходимо обрабатывать. В этой статье вы узнаете о лучших способах хранения и обработки метрик мониторинга для снижения расходов и о том, как VictoriaMetrics может в этом помочь.

*В этой статье рассматриваются только решения с открытым исходным кодом. VictoriaMetrics —* [*проект с открытым исходным кодом*](https://victoriametrics.com/blog/bsl-is-short-term-fix-why-we-choose-open-source/)*. Вы получите максимальную пользу от этой статьи, если знакомы с Prometheus, Thanos, Mimir или VictoriaMetrics.*

См. вторую статью из этой серии — [Как снизить расходы на мониторинг: более разумный подход к данным](https://habr.com/ru/articles/849176/).



---

Прежде чем мы сможем говорить о снижении расходов на мониторинг, нам сначала нужно понять системы мониторинга. Ниже приведена типичная архитектура мониторинга:

![Пример мониторинга по модели pull](picture/95ca5635ac0d4f47b974e00e1d6b92e6.webp)

Пример мониторинга по модели pull

В приведенной выше архитектуре есть **система мониторинга**, которая отвечает за периодический **сбор метрик** со **служб, о которых ей известно**. Эта архитектура называется [моделью pull](https://docs.victoriametrics.com/keyconcepts/#pull-model), так как система мониторинга активно **запрашивает** данные. Модель pull была популяризирована Prometheus и также поддерживается VictoriaMetrics.

Дополнением к модели pull является [модель push](https://docs.victoriametrics.com/keyconcepts/#push-model):

![Пример мониторинга по модели push](picture/a941a3cfcefcf598c2ea10a4beea40aa.webp)

Пример мониторинга по [модели push](https://docs.victoriametrics.com/keyconcepts/#push-model)

**Модель push** является обратной по отношению к модели pull. В модели push **приложения знают о системе мониторинга** и отвечают за отправку метрик в нее. Модель push поддерживается VictoriaMetrics с самого начала, поддерживается Mimir, и недавно Prometheus [ввел поддержку](https://prometheus.io/docs/prometheus/latest/feature_flags/#remote-write-receiver) для нее за флагом функции.

Можно смешивать и сочетать две модели:

![Пример смешанного мониторинга: push и pull](picture/52962344a1c231e2f3de41d8a75ca1d1.webp)

Пример смешанного мониторинга: push и pull

В смешанной топологии обычно есть агент, который отвечает за сбор метрик, подобно системе мониторинга в модели pull. Агент размещается как можно ближе к приложениям, в идеале в одном кластере. После сбора метрик агент отвечает за их отправку в систему мониторинга, как это делало бы приложение в модели push.

Независимо от того, какую архитектуру вы выберете, в конце месяца будут четыре фактора, которые повлияют на ваш счет за инфраструктуру:

* Процессор
* Память
* Диск
* Сеть

Повышение эффективности ваших систем немного похоже на попытку выиграть больше автомобильных гонок, поскольку у вас есть несколько путей к победе: **либо приобрести более быстрый автомобиль, либо стать лучшим водителем, либо и то, и другое**. Более быстрый автомобиль в терминах мониторинга может означать использование более эффективного программного обеспечения, в то время как стать лучшим водителем может означать применение трюков для уменьшения работы, которую должна выполнять ваша система мониторинга. В этой серии статей вы увидите, как **снизить расходы**, используя эти два разных подхода.

### Замена Prometheus на VictoriaMetrics

Эквивалент приобретения более быстрого автомобиля в мониторинге — это замена вашей текущей базы данных на более эффективную. В этом разделе мы рассмотрим замену Prometheus на VictoriaMetrics.

VictoriaMetrics является заменой Prometheus «из коробки», практически без необходимости изменения конфигурации. Во многих случаях вы можете просто заменить бинарные файлы. Если вам интересно попробовать VictoriaMetrics с вашей системой, ознакомьтесь с [документацией](https://docs.victoriametrics.com/Single-server-VictoriaMetrics.html#how-to-scrape-prometheus-exporters-such-as-node-exporter) для получения дополнительной информации.

#### Настройка бенчмарка

Для целей бенчмаркинга мы используем наш инструмент [Remote write benchmark](https://github.com/VictoriaMetrics/prometheus-benchmark), который мы уже упоминали в предыдущих статьях:

* [Как генерировать 100 миллионов семплов/с данных, похожих на данные с прода](https://victoriametrics.com/blog/benchmark-100m/)
* [Grafana Mimir и VictoriaMetrics: тесты производительности](https://victoriametrics.com/blog/mimir-benchmark/)

Этот бенчмарк был разработан для тестирования баз данных временных рядов путем **отправки** данных. Хотя Prometheus поддерживает как модели **push**, так и **pull**, его модель pull сейчас кажется намного более эффективной и оптимизированной. Поэтому, чтобы сделать бенчмарк честным, мы настроили Prometheus и одноузловой VictoriaMetrics на сбор данных с одного и того же списка целей, используя одну и ту же конфигурацию, и выполнение одного и того же списка запросов на чтение, генерируемых автономным [ruler](https://docs.victoriametrics.com/vmalert.html):

![Архитектура бенчмарк-набора для тестирования нагрузки чтения/записи на VictoriaMetrics и Prometheus. Репозиторий бенчмарка доступен здесь](picture/c0eb368e8801d055dc775a41c13f3d1d.webp)

Архитектура бенчмарк\-набора для тестирования нагрузки чтения/записи на VictoriaMetrics и Prometheus. Репозиторий бенчмарка доступен [здесь](https://github.com/VictoriaMetrics/prometheus-benchmark/tree/vmsingle#prometheus-benchmark)

Вот некоторые из спецификаций для этого бенчмарка:

* VictoriaMetrics и Prometheus работают на одной и той же конфигурации экземпляра (**3 vCPU, 12 GiB RAM**);
* **1000 целей Node Exporter** для [симуляции мониторинга](https://victoriametrics.com/blog/benchmark-100m/) **1000 экземпляров**, каждая цель предоставляет около **1200** уникальных временных рядов;
* Интервал сбора данных **15 с**, определяет, как часто собирать данные с целей. Для 1000 целей по 1200 временных рядов каждая, прием данных должен составлять около `1000 * 1200 / 15 с = 80 тыс. семплов/с`;
* Интервал оценки правил **30 с**, определяет, как часто отправлять запросы на чтение. Для [этого набора правил](https://github.com/VictoriaMetrics/prometheus-benchmark/blob/main/chart/files/alerts.yaml) бенчмарк будет генерировать около 1 запроса на чтение в секунду;
* **Churn rate 5%** каждые 10 минут, определяет, сколько целей изменит свои метки в течение 10\-минутного интервала. Другими словами, каждые 10 минут будет генерироваться `1000 целей * 5% * 1200 = 60 тыс. новых временных рядов`. *(Churn rate можно перевести как "частота изменений", "интенсивность изменений" или "скорость обновления данных")*.

**Churn rate** выше симулирует изменение целей метрик с течением времени. Это представляет особый интерес при мониторинге приложений, развернутых в Kubernetes. В Kubernetes есть понятие pod\-ов, которые являются эфемерными экземплярами приложения. Всякий раз, когда развертывается новая версия приложения или требуется перезапуск, создается новый pod. Поскольку каждый pod имеет случайно сгенерированное имя, воссоздание pod\-а создает новую цель метрик и делает старую недействительной.

#### Результаты

Бенчмарк выполнялся в течение **семи дней** в этом эксперименте. Метрики системы как для Prometheus, так и для VictoriaMetrics были зафиксированы на снимке Grafana [здесь](https://snapshots.raintank.io/dashboard/snapshot/kwnklT14O2BlOcYbA12kH4S245zMgHfM?orgId=2).

В среднем скорость приема данных как для Prometheus, так и для VictoriaMetrics составляла около **\~80 тыс. семплов в секунду**:

![Скорость приема семплов/с в VictoriaMetrics и Prometheus во время бенчмарка](picture/f2badeefe0f51cf1d8db95662743feed.webp)

Скорость приема семплов/с в VictoriaMetrics и Prometheus во время бенчмарка

Набор временных рядов, в которые база данных недавно записывала данные или из которых считывала данные, называется набором [активных временных рядов](https://docs.victoriametrics.com/faq/#what-is-an-active-time-series). Обычно количество активных временных рядов оказывает наибольшее влияние на использование памяти. Ниже приведен график, показывающий количество активных временных рядов для Prometheus и VictoriaMetrics во время этого бенчмарка:

![Активные временные ряды VictoriaMetrics и Prometheus во время бенчмарка](picture/d959adf70e533dfca859a935dec99f9b.webp)

Активные временные ряды VictoriaMetrics и Prometheus во время бенчмарка

Хотя две линии выглядят совершенно по\-разному, это связано только с тем, как две базы данных измеряют активные временные ряды. VictoriaMetrics имеет скользящее временное окно, в то время как Prometheus (Thanos и Mimir) имеет **фиксированные двухчасовые интервалы** для сбора метрик и их сброса на диск.

С точки зрения процессора, VictoriaMetrics и Prometheus вели себя одинаково:

![Использование процессора VictoriaMetrics и Prometheus во время бенчмарка](picture/f58742ea76bd6bed2d70ad01a170f685.webp)

Использование процессора VictoriaMetrics и Prometheus во время бенчмарка

Хотя приведенные выше результаты были сопоставимы между VictoriaMetrics и Prometheus, результаты становятся интересными, когда мы смотрим на **задержку запроса**. VictoriaMetrics была в среднем в **16 раз быстрее**, чем Prometheus, используя тот же список правил оповещения и тот же набор данных:

![Задержка (50-й процентиль) запросов на чтение для VictoriaMetrics и Prometheus во время бенчмарка](picture/96eb335e4c5a2624a50e878a03d6ade6.webp)

Задержка (50\-й процентиль) запросов на чтение для VictoriaMetrics и Prometheus во время бенчмарка

Приведенный выше график находится на **50\-м процентиле**. Это означает, что медианное время, которое требуется VictoriaMetrics для обработки запроса, в **16 раз меньше**, чем среднее время, которое требуется Prometheus. Этот разрыв сокращается, когда мы смотрим на **99\-й процентиль**, т. е. самые медленные запросы, но VictoriaMetrics все еще в **1,9 раза быстрее**:

![Задержка (99-й процентиль) запросов на чтение для VictoriaMetrics и Prometheus во время бенчмарка](picture/1a2892d9a9cc385c45956b83735ccfd9.webp)

Задержка (99\-й процентиль) запросов на чтение для VictoriaMetrics и Prometheus во время бенчмарка

Помимо более быстрой обработки запросов на чтение, VictoriaMetrics также использовала на **1,7x меньше памяти**, чем Prometheus:

![Использование памяти VictoriaMetrics и Prometheus во время бенчмарка](picture/c9594bca3044038ff5428c6e761a3729.webp)

Использование памяти VictoriaMetrics и Prometheus во время бенчмарка

VictoriaMetrics использует улучшенную версию метода сжатия Gorilla, который использует Prometheus, как описано нашим техническим директором, Александром Валялкиным, в [этой статье](https://faun.pub/victoriametrics-achieving-better-compression-for-time-series-data-than-gorilla-317bc1f95932). В результате VictoriaMetrics использует в **2,5 раза меньше дискового пространства** для одних и тех же данных:

![Использование диска VictoriaMetrics и Prometheus во время бенчмарка](picture/fb297c5b40bbb5139d351a0b01a1e3d9.webp)

Использование диска VictoriaMetrics и Prometheus во время бенчмарка

Ниже приведена сводка результатов этого эксперимента:



|  | Prometheus | VictoriaMetrics |
| --- | --- | --- |
| Среднее использование CPU | 0\.79/3 cores | 0\.76/3 cores |
| Использование диска | 83\.5 GiB | ✅ 33 GiB |
| Максимальное использование памяти | 8\.12/12 GiB | ✅ 4\.5/12 GiB |
| Задержка чтения (50\-й процентиль) | 70\.5ms | ✅ 4\.3ms |
| Задержка чтения (99\-й процентиль) | 7s | ✅ 3\.6s |

Замена Prometheus на VictoriaMetrics может обеспечить **огромный прирост при минимальных усилиях**! Это одна из самых простых вещей, которые можно сделать для снижения расходов на мониторинг. Однако VictoriaMetrics предоставляет дополнительные инструменты и функции для повышения экономичности и производительности. См. вторую статью из этой серии — [Как снизить расходы на мониторинг: более разумный подход к данным](https://victoriametrics.com/blog/reducing-costs-p2/).

